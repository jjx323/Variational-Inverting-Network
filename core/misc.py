#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Aug 20 13:57:55 2019

@author: jjx323
"""
import numpy as np
import scipy.sparse as sps 
import scipy.sparse.linalg as spsl 
import fenics as fe

#########################################################################
fe.parameters['linear_algebra_backend'] = 'Eigen'
def trans_to_python_sparse_matrix(M):
    '''
    This function transfer the sparse matrix generated by FEniCS 
    into numpy sparse array. 
    Example: 
    A_low_level = fe.assemble(fe.inner(u, v)*fe.dx)
    A = trans_to_python_sparse_matrix(A_low_level)
    '''
    row, col, val = fe.as_backend_type(M).data()
    return sps.csr_matrix((val, col, row))

#########################################################################
def make_interpolation_matrix(xs, V):
    '''
    This function generate measurement matrix 
    xs: measurement points
    V:  function space generated by FEniCS
    Example: 
    Let V be a function space generated by FEniCS
    u is a function genrated by FEniCS based on function space V
    points = np.array([(0,0), (0.5,0.5)])
    S = make_interpolate_matrix(ponits, V)
    S@u.vector()[:] is a vector (u[0, 0], u[0.5, 0.5])
    '''
    nx, dim = xs.shape
    mesh = V.mesh()
    coords = mesh.coordinates()
    cells = mesh.cells()
    dolfin_element = V.dolfin_element()
    dofmap = V.dofmap()
    bbt = mesh.bounding_box_tree()
    sdim = dolfin_element.space_dimension()
    v = np.zeros(sdim)
    rows = np.zeros(nx*sdim, dtype='int')
    cols = np.zeros(nx*sdim, dtype='int')
    vals = np.zeros(nx*sdim)
    for k in range(nx):
        # Loop over all interpolation points
        x = xs[k, :]
        if dim > 1:
            p = fe.Point(x[0], x[1])
        elif dim == 1:
            p = fe.Point(x)
        # Find cell for the point
        cell_id = bbt.compute_first_entity_collision(p)
        # Vertex coordinates for the cell
        xvert = coords[cells[cell_id, :], :]
        # Evaluate the basis functions for the cell at x
        v = dolfin_element.evaluate_basis_all(x, xvert, cell_id)
        jj = np.arange(sdim*k, sdim*(k+1))
        rows[jj] = k
        # Find the dofs for the cell
        cols[jj] = dofmap.cell_dofs(cell_id)
        vals[jj] = v

    ij = np.concatenate((np.array([rows]), np.array([cols])), axis=0)
    M = sps.csr_matrix((vals, ij), shape=(nx, V.dim()))
    return M

#########################################################################
def gene_points(x, y):
    '''
    If x = (x_1,x_2,\cdots, x_n),  y = (y_1,y_2,\cdots, y_m), 
    then points = gene_points(x, y) will be 
    ((x_1, y_1), (x_1, y_2), \cdots, (x_1, y_m), (x_2, y_1), \cdots (x_2, y_m), 
    \cdots, (x_n, y_m)))
    '''
    points = []
    for xx in x:
        for yy in y:
            points.append((xx, yy))
    return np.array(points)

#########################################################################
def geneM_half_iter(M, max_iter=700, approTol=1e-5):
    '''
    generate squart root of a large sparse matrix
    max_iter: maximum iteration number
    approTol: elements smaller than this threshold value will be set to zero,
              which make the approximation of the squart root still is a sparse matrix
    '''
    nx, ny = M.shape
    alpha = 0.5
    Xk = (1.0/(2*alpha))*sps.eye(nx)
        
    for k in range(max_iter):
        Xk = Xk + alpha*(M - Xk.dot(Xk))                   
        ## set small elements to zeros to save memory
        row, col, vals = sps.find(Xk)
        index = (vals < approTol)
        rr, cc = row[index], col[index]
        Xk[rr, cc] = 0
    
    return Xk

#########################################################################
def expMatrix(A, p=2, max_iter=100, approTol=1e-5):
    nx, ny = A.shape
    Xk = sps.eye(nx)*0.0
    
    for k in range(max_iter):
        temp = Xk
        for j in range(p-1):
            temp = temp@Xk
        Xk = Xk + (1/p)*(A - temp)                     
        ## set small elements to zeros to save memory
        row, col, vals = sps.find(Xk)
        index = (vals < approTol)
        rr, cc = row[index], col[index]
        Xk[rr, cc] = 0
        ## set small elements to zeros to save memory       
#        print("Iterate number is ", k)
    
    return Xk

##########################################################################
# the project command in FEniCS seems has some bug, it occupy memory and make the program out of memory! 
def my_project(fun, V=None, flag='only_vec'):
    if V is None:
        V = fun.function_space()
    u = fe.TrialFunction(V)
    v = fe.TestFunction(V)
    a = fe.assemble(fe.inner(u, v)*fe.dx)
    b = fe.assemble(fe.inner(fun, v)*fe.dx)
    A = trans_to_python_sparse_matrix(a)
    sol = fe.Function(V)
    sol.vector()[:] = spsl.spsolve(A, b[:])
    if flag == 'only_vec':
    	return sol.vector()[:]
    elif flag == 'only_fun':
    	return sol
    else:
    	return (sol, sol.vector()[:])

## the above function may also lead to memory problem
class MY_Project(object):
    def __init__(self, V):
        self.V = V
        self.u = fe.TrialFunction(V)
        self.v = fe.TestFunction(V)
        A_ = fe.assemble(fe.inner(self.u, self.v)*fe.dx)
        self.A = trans_to_python_sparse_matrix(A_)
        
    def project(self, fun):
        b_ = fe.assemble(fe.inner(fun, self.v)*fe.dx)
        return spsl.spsolve(self.A, b_[:])
        
############################################################################
def make_symmetrize(A):
    return 0.5*(A.T + A)

############################################################################
def save_expre(filename, contents): 
  fh = open(filename, 'w') 
  fh.write(contents) 
  fh.close() 

############################################################################
def load_expre(filename): 
  fh = open(filename, 'r') 
  a = fh.read()
  fh.close() 
  return a

############################################################################
def smoothing(fun, bc=None, alpha=0.1):
    V = fun.function_space()
    u = fe.TrialFunction(V)
    v = fe.TestFunction(V)
    alpha = fe.Constant(str(alpha))
    A = fe.assemble((alpha*fe.inner(fe.grad(u), fe.grad(v)) + fe.inner(u, v))*fe.dx)
    b = fe.assemble(fun*v*fe.dx)
    if bc is not None:
        bc.apply(A, b)
    sol = fe.Function(V)
    fe.solve(A, sol.vector(), b)
    return sol

############################################################################
def print_my(*string, end=None, color=None):
    if color == 'red':
        print('\033[1;31m', end='')
        if end == None: print(*string)
        else: print(*string, end=end)
        print('\033[0m', end='')
    elif color == None:
        print(*string, end=end)
    elif color == 'blue': 
        print('\033[1;34m', end='')
        if end == None: print(*string)
        else: print(*string, end=end)
        print('\033[0m', end='')
    elif color == 'green':
        print('\033[1;32m', end='')
        if end == None: print(*string)
        else: print(*string, end=end)
        print('\033[0m', end='')








